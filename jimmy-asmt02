package com.CSC3400;
import java.lang.reflect.Array;
import java.security.Key;
import java.util.Scanner;
import java.util.Enumeration;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.Collection;
import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import org.w3c.dom.ls.LSOutput;
import java.util.List;
import java.util.ArrayList;
import java.lang.String;
import java.util.stream.BaseStream;
import java.util.stream.Stream;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

// lord have mercy on my soul
// to the grader and to Profesor Duc Ta: please realize i have tried so hard on this, and i realize why this is all so horrible (which i will detail in my report)
// it... works for the most part
// please go easy


public class Dictionary {
    // creating dictionary objects in order to retrieve speech and definition
    private final String speech;
    private final String definition;

    public Dictionary(String speech, String definition) { // constructor for main class: defines speech and definition
        this.speech = speech;
        this.definition = definition;
    }
    public String getSpeech() {
        return this.speech;
    }
    public String getDefinition() {
        return this.definition;
    }

    // the enum
    private enum enumWords {
        //        // actual enum entries here
        arrow("Arrow", "noun", new String[]{"Here is one arrow: <IMG> -=>> </IMG>"}),
        booknoun("Book", "noun", new String[]{
                "A set of pages.",
                "A written work published in printed or electronic form.",}),
        bookverb("Book", "verb", new String[]{
                "To arrange for someone to have a seat on a plane.",
                "To arrange for something on a particular date."}),
        distinctAdjective("Distinct", "adjective", new String[]{
                "Familiar. Worked in Java",
                "Unique. No duplicates. Clearly different or of a different kind."}),
        distinctAdverb("Distinct", "adverb", new String[]{"Uniquely. Written \"distinctly\""}),
        distinctNoun("Distinct", "noun", new String[]{
                "A keyword in this assignment.",
                "A keyword in this assignment.",
                "A keyword in this assignment.",
                "An advanced search option..",
                "Distinct is a parameter in this assignment."}),
        placeholderAdjective("Placeholder", "adjective", new String[]{
                "To be updated...",
                "To be updated..."
        }),
        placeholderAdverb("Placeholder", "adverb", new String[]{"To be updated..."}),
        placeholderConjunction("Placeholder", "conjunction", new String[]{"To be updated..."}),
        placeholderInterjection("Placeholder", "interjection", new String[]{"To be updated..."}),
        placeholderNoun("Placeholder", "noun", new String[]{
                "To be updated...",
                "To be updated...",
                "To be updated..."
        }),
        placeholderPreposition("Placeholder", "preposition", new String[]{"To be updated..."}),
        placeholderPronoun("Placeholder", "pronoun", new String[]{"To be updated..."}),
        placeholderVerb("Placeholder", "verb", new String[]{"To be updated..."}),
        reverseAdjective("Reverse", "adjective", new String[]{"On back side.",
                "Opposite to usual or previous arrangement."
        }),
        reverseNoun("Reverse", "noun", new String[]{
                "A dictionary program's parameter.",
                "Change to opposite direction.",
                "The opposite.",
                "To be updated...",
                "To be updated...",
                "To be updated...",
                "To be updated..."
        }),
        reverseVerb("Reverse", "verb", new String[]{
                "Change something to opposite.",
                "Go back",
                "Revoke ruling.",
                "To be updated...",
                "To be updated...",
                "Turn something inside out."
        }),
        // Additional words needed for the to match the output.
        Chocolate("Chocolate", "noun", new String[]{"A delicious piece of candy."}),
        Computer("Computer", "noun", new String[]{"A device that processes things very quickly."}),
        Sleep("Sleep", "verb", new String[]{"To rest in a state of unconsciousness, typically at night.."}),
        PlaceVerb("Place", "verb", new String[]{"To set down in a spot."}),
        PlaceNoun("Person", "noun", new String[]{"A space or area.", "A feeling of belonging."}),
        Joker("Joker", "noun", new String[]{"A person who is humorous very often, usually telling jokes.", "One of many faces on playing cards."}),
        Truth("Truth", "noun", new String[]{"The objective retelling of circumstances and events."}),
        JumpNoun("Jump", "noun", new String[]{"A stunt, usually done with a bungie cord, or from a plane with a parachute.",}),
        JumpVerb("Jump", "Verb", new String[]{"To attack someone in a group by surprise"}),
        Person("Person", "noun", new String[]{"An individual human being."}),
        LoveNoun("Love", "noun", new String[]{"A feeling of strong affection.", "Attraction to another person."}),
        LoveVerb("Love", "verb", new String[]{"Expressing strong feelings regarding something or someone.", "To be romantic with another person."}),
        Jungle("Jungle", "noun", new String[]{"A forest typically filled with varied wildlife."}),
        Discord("Discord", "noun", new String[]{"Chaos or a lack of order.", "An online communication program."}),
        Music("Music", "noun", new String[]{"Sounds that produce rhythm, and is considered enjoyable to many people."}),
        Voice("Voice", "noun", new String[]{"A person's ability to speak."}),
        Pizza("Pizza", "noun", new String[]{ "Delicious italian food."});
        // END OF ENUM

        // constructor for enum
        private enumWords(String word, String speech, String[] definitions) { // constructor for the enum to create word, speech and definitions
            this.word = word.toLowerCase();
            this.speech = speech;
            this.definitions = definitions;
        }

        // Declaration of word, speech, definitions
        private String word;
        private String speech;
        private String[] definitions;

        // Getters, no setters
        public String getWord() {
            return word;
        }
        public String getSpeech() {
            return speech;
        }
        public String[] getDefinitions() {
            return definitions;
        }
    }

    // Methods for Distinct, Reverse, Speech, and all possible combinations needed for this project.
    // ALL methods utilize several inputs and concatentation. This is very messy, but it was the easiest way I could come up at the time. Could be significantly improved.
    // Distinct
    public static void Distinct(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) { // dis important
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (!modifierArray.contains(concatTemp)) {
                System.out.println(concatTemp);
                modifierArray.add(concatTemp);
                continue;
            }
        }
    }
    // Reverse
    public static void Reverse(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            modifierArray.add(concatTemp);
        }
        for (int i = modifierArray.size() - 1; i >= 0; i--) {
            System.out.println(" " + modifierArray.get(i));
        }
    }
    // Speech
    public static void Speech(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        List<Dictionary> list = hashMap.get(splitInput[0]);
        for (Dictionary speechAndDefinitions : list) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (speechAndDefinitions.getSpeech().toLowerCase().equals(splitInput[1].toLowerCase())) {
                System.out.println(" " + concatTemp);
            }
        }
        if (list.stream().noneMatch(dictionary -> splitInput[1].toLowerCase().equals(dictionary.getSpeech().toLowerCase()))) {
            System.out.println(" <NOT FOUND> To be considered for next release. Thank you.\n|\n|\n PARAMETER HOW-TO, please enter:\n" +
                    " 1. A search key -then 2. An optional part of speech -then\n" +
                    " 3. An optional 'distinct' -then 4. An optional 'reverse'");
        }
    }
    // Distinct + Reverse
    public static void distinctReverse(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (!modifierArray.contains(concatTemp)) {
                modifierArray.add(concatTemp);
                continue;
            }
        }
        for (int i = modifierArray.size() -1; i >= 0; i--) {
            System.out.println(" " + modifierArray.get(i));
        }
    }
    // Speech + Reverse
    public static void speechReverse(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (speechAndDefinitions.getSpeech().toLowerCase().equals(splitInput[1].toLowerCase())) {
                modifierArray.add(concatTemp);
            }
        }
        if (modifierArray.isEmpty()) {
            System.out.println("HELP");
        }
        for (int i = modifierArray.size() -1; i >= 0; i--) {
            System.out.println(" " + modifierArray.get(i));
        }
    }
    // Sppech + Distinct
    public static void speechDistinct(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (speechAndDefinitions.getSpeech().toLowerCase().equals(splitInput[1].toLowerCase()) && !modifierArray.contains(concatTemp)) {
                modifierArray.add(concatTemp);
            }
        }
        if (modifierArray.isEmpty()) {
            System.out.println("HELP");
        }
        for (int i = 0; i < modifierArray.size(); i++) {
            System.out.println(" " + modifierArray.get(i));
        }
    }
    // All three: Reverse, Speech and Distinct
    public static void allThree(HashMap<String, List<Dictionary>> hashMap, String[] splitInput, String clean, ArrayList<String> modifierArray) {
        for (Dictionary speechAndDefinitions : hashMap.get(splitInput[0].toLowerCase())) {
            String concatTemp = clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition();
            if (speechAndDefinitions.getSpeech().toLowerCase().equals(splitInput[1].toLowerCase()) && !modifierArray.contains(concatTemp)) {
                modifierArray.add(concatTemp);
            }
        }
        if (modifierArray.isEmpty()) {
            System.out.println("HELP");
        }
        for (int i = modifierArray.size() -1; i >= 0; i--) {
            System.out.println(" " + modifierArray.get(i));
        }
    }
    // This is a method that simply prints all definitions of a word, regardless of filter. If the word doesn't exist, it displays the necessary error to indicate such.
    public static void printDefinitions(HashMap<String, List<Dictionary>> hashMap, String lowercaseInput, String clean, String incorrectWord, String howTo) {
        if (hashMap.containsKey(lowercaseInput)) {
            List<Dictionary> list = hashMap.get(lowercaseInput);
            for (Dictionary speechAndDefinitions : list) {
                System.out.println(" " + clean + " [" + speechAndDefinitions.getSpeech() + "] : " + speechAndDefinitions.getDefinition());
            }
            if (list.isEmpty()) {
                System.out.println(incorrectWord);
                System.out.println(howTo);
            }
        } else {
            System.out.println(incorrectWord); // otherwise it gives a statement saying the word doesn't exist
        }
    }

    // Main. Note, I KNOW this program is a huge mess, but it works. I have engaged with many peers and realize I have many things to do better, especially starting with a good foundation.
    public static void main(String args[]) {
     System.out.println("! Loading data..."); // to indicate it loads data at start into structure

        List<Dictionary> listTemp = new ArrayList<Dictionary>(); // list declared in order to be put into our hashmap, which will store our speech and definitions
        HashMap<String, List<Dictionary>> hashMap = new HashMap<String, List<Dictionary>>(); // our data structuree, which is a hashmap with a list inside
        String[] definitionsTemp;

        int numberOfDefinitions = 0; // counter for definitions

        // our code to load everything from enum into data structure
        for (enumWords enumIterator : enumWords.values()) {
            if (!hashMap.containsKey((enumIterator.getWord()))) {
                hashMap.put(enumIterator.getWord(), new ArrayList<Dictionary>());
            }
            for (int i = 0; i < enumIterator.getDefinitions().length; i++) {
                hashMap.get(enumIterator.getWord()).add(new Dictionary(enumIterator.getSpeech(), enumIterator.getDefinitions()[i]));
                numberOfDefinitions++;
            }
        }

       System.out.println("! Loading completed...\n"); // line to indicate that the enum's data is loaded into the data structure
        // below this point, we should not be using anything directly from the enum, but rather from the hashmap.

        // intro statement that displays the number of keywords, and the total number of definitions
        System.out.println("==== DICTIONARY 340 JAVA ==== \n---- Keywords: " + hashMap.size() + "\n---- Definitions: " + numberOfDefinitions + "\n");
        // set-up strings for the code below
        String howTo =
                " PARAMETER HOW-TO, please enter:\n" +
                " 1. A search key -then 2. An optional part of speech -then\n" +
                " 3. An optional 'distinct' -then 4. An optional 'reverse'\n" +
                "|";
        String incorrectWord = " <NOT FOUND> To be considered for next release. Thank you.";

        Scanner scannerInput = new Scanner(System.in); // the scanner for user input
        String input; // String used for user's input.
        int searchLoop = 0; // integer used as the condition for the 'do' loop to keep going
        int searchNumber = 0; // number that represents how many time a person has searched. It increase every time we loop through.

        // line 287 to 297 is making a list in order to check what types of speech from the enum were put in, in order for our other functions to work. we call back to it often
        List<String> listForSpeech = new ArrayList<String>();

        for (List<Dictionary> listIterator : hashMap.values()) {
            for (Dictionary dictionaryIterator : listIterator) {
                String typeOfSpeech = dictionaryIterator.getSpeech();
                listForSpeech.add(typeOfSpeech);
            }
        }
        String[] partsOfSpeech = new String[listForSpeech.size()];
        listForSpeech.toArray(partsOfSpeech);

        // our do loop, where everything runs
        do {
            searchNumber++; // keeps track of times we search
            System.out.print("Search [" + searchNumber + "] : ");
            String userInput = scannerInput.nextLine();  // input is inside the loop so it will always ask for a new line, and change 'input' as a string
            String lowercaseInput = userInput.toLowerCase(); // turns everything to lowercase so it isn't so pesky for the program to read

            String distinct = "distinct"; // strings distinct and reverse made so it's cleaner
            String reverse = "reverse";
            if (lowercaseInput.equals("!q")) { // checks first thing if the user wants to quit, then just stops
                System.out.println("\n---- THANK YOU ----");
                break;
            }

            System.out.println("|"); // string needed for formatting the output's appearance

            String[] splitInput = userInput.toLowerCase().split(" "); // this splits the user's input into four words at individual space

            ArrayList<String> modifierArray = new ArrayList<String>(); // array declared to store concatenated strings, for use for each function


            // function that simply pulls up all possible definitions if it's simply one word
            if(lowercaseInput.isBlank() || lowercaseInput.isEmpty() ||lowercaseInput.equals("!help")) {
                System.out.println(howTo);
                continue;
            }
            String clean = splitInput[0].substring(0, 1).toUpperCase() + splitInput[0].substring(1).toLowerCase(); // string that just makes all words start with capital, everything else lowercase

            if (!hashMap.containsKey(splitInput[0])) {
                System.out.println(incorrectWord + "\n|\n|\n" + howTo);
                continue;
            }

            // flags to check the length
            boolean lengthTwo = false;
            boolean lengthThree = false;
            boolean lengthFour = false;
            boolean lengthAboveFour = false;

            if (splitInput.length == 1) { // if length = 1, simply print out every definition as needed via the function
                printDefinitions(hashMap, lowercaseInput, clean, incorrectWord, howTo);
            }
            // if length is higher than 1, it activates flags to check what length it is
            if (splitInput.length == 2) {
                lengthTwo = true;
            } else if (splitInput.length == 3) {
                lengthTwo = true;
                lengthThree = true;
            } else if (splitInput.length == 4) {
                lengthTwo = true;
                lengthThree = true;
                lengthFour = true;
            } else if (splitInput.length > 4) {
                lengthAboveFour = true;
            }

            // booleans to check which function to do
            boolean distinctDo = false;
            boolean reverseDo = false;
            boolean speechDo = false;

            boolean lengthTwoPrint = false;

            // below from 366 to 427 is simply checks on what function will do what. yes i know this is horribly messy and unrefined, but i had to do what i had to do
            if (lengthTwo == true) {
                //
                if (splitInput[1].equals(distinct)) {
                    distinctDo = true;
                }
                if (splitInput[1].equals(reverse)) {
                    reverseDo = true;
                }
                if (Arrays.stream(partsOfSpeech).anyMatch(splitInput[1]::equals)) {
                    speechDo = true;
                }
                if (!splitInput[1].equals(distinct) && !splitInput[1].equals(reverse) && !Arrays.stream(partsOfSpeech).anyMatch(splitInput[1]::equals) ) {
                    if (!distinctDo) {
                        System.out.println(" <The entered 2nd parameter '" + splitInput[1] + "' is NOT 'distinct'.>");
                    }
                    if (!reverseDo) {
                        System.out.println(" <The entered 2nd parameter '" + splitInput[1] + "' is NOT 'reverse'.>");
                    }
                    if (!speechDo) {
                        System.out.println(" <The entered 2nd parameter '" + splitInput[1] + "' is NOT a part of speech.>");
                    }
                    System.out.println(" <The entered 2nd parameter '" + splitInput[1] + "' was disregarded.>");
                    System.out.println(" <The 2nd parameter should be a part of speech or 'distinct' or 'reverse'.>\n|\n|");
                    lengthTwoPrint = true;
                }
            }

            if (lengthThree == true) {
                if (splitInput[2].equals(distinct)) {
                    distinctDo = true;
                }
                if (splitInput[2].equals(reverse)) {
                    reverseDo = true;
                }
                if (!splitInput[2].equals(distinct) && !splitInput[2].equals(reverse)) {
                    if (!distinctDo) {
                        System.out.println(" <The entered 3rd parameter '" + splitInput[2] + "' is NOT 'distinct'.>");
                    }
                    if (!reverseDo) {
                        System.out.println(" <The entered 3rd parameter '" + splitInput[2] + "' is NOT 'reverse'.>");
                    }
                    System.out.println(" <The entered 3rd parameter '" + splitInput[2] + "' was disregarded.>");
                    System.out.println(" <The 3rd parameter should be 'distinct' or 'reverse'.>\n|\n|");
                }

            }

            if (lengthFour == true) {
                if (splitInput[3].equals(reverse)) {
                    reverseDo = true;
                } else {
                    System.out.println(" <The entered 4th parameter '" + splitInput[2] + "' is NOT 'reverse'.>");
                    System.out.println(" <The entered 4th parameter '" + splitInput[3] + "' was disregarded.>");
                    System.out.println(" <The 4th parameter should be 'reverse'.>\n|\n|");
                }
            }
            if (lengthAboveFour) {
                System.out.println(howTo);
            }
            if (lengthTwoPrint) {
                printDefinitions(hashMap, splitInput[0], clean, incorrectWord, howTo);
            }

            // Distinct alone
            if (distinctDo == true && reverseDo == false && speechDo == false) {
                Distinct(hashMap, splitInput, clean, modifierArray);
            }
            // Reverse alone
            if (distinctDo == false && reverseDo == true && speechDo == false) {
                Reverse(hashMap, splitInput, clean, modifierArray);
            }
            // Speech alone
            if (distinctDo == false && reverseDo == false && speechDo == true) {
                Speech(hashMap, splitInput, clean, modifierArray);
            }
            // Speech + Reverse
            if (distinctDo == false && reverseDo == true && speechDo == true) {
                speechReverse(hashMap, splitInput, clean, modifierArray);
            }
            // Distinct + Reverse
            if (distinctDo == true && reverseDo == true && speechDo == false) {
                distinctReverse(hashMap, splitInput, clean, modifierArray);
            }
            // Speech + Distinct
            if (distinctDo == true && reverseDo == false && speechDo == true) {
                speechDistinct(hashMap, splitInput, clean, modifierArray);
            }
            // All three
            if (distinctDo == true && reverseDo == true && speechDo == true) {
                allThree(hashMap, splitInput, clean, modifierArray);
            }
            if (!lengthAboveFour) {
                System.out.println("|"); // string for the format of the output
            }
            // resets all booleans to false
            distinctDo = false;
            reverseDo = false;
            speechDo = false;
            lengthTwo = false;
            lengthThree = false;
            lengthFour = false;
        } while (searchLoop == 0); // doesn't ever stop, only way to exit is by doing !q, which will use "break" to halt the program, then finish
    } // END OF MAIN
} // END OF PROGRAM



